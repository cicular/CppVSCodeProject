https://code.visualstudio.com/docs/languages/cpp#_navigating-code
-------------------------------------

マクロ定数の特徴

    スコープ: マクロ定数は、その定義が有効な範囲でのみ使用可能です。通常、ファイル全体で有効です。
    型: マクロ定数には型がありません。ただのテキスト置換なので、型のチェックが行われません。
    デバッグ: マクロ定数はデバッグが難しいことがあります。定数の置き換えはプリプロセッサによって行われるため、エラーが発生した場合のトレースが難しくなります。
    コンパイル時間の影響: マクロ定数はプリプロセッサが処理するため、コンパイル時間に影響を与えることがあります。

注意点

マクロ定数を使う際には、以下の点に注意する必要があります：

    名前の衝突: グローバルに定義されるため、名前が他の部分と衝突するリスクがあります。
    型安全性の欠如: マクロ定数は型を持たないため、誤った型で使用されてもコンパイラがエラーを検出できません。

マクロ定数を更新することは可能ですか？
→CでもC++でもマクロ定数を更新することはできません。マクロ定数はプリプロセッサディレクティブを使用して定義され、コンパイル時に一度だけ定義されるため、その後に値を変更することはできません。

-------------------------------------

c++のコンパイラにはどのようなものがありますか？また、違いはなんですか？

主なC++コンパイラ

・GCC (GNU Compiler Collection)
オープンソースのコンパイラで、さまざまなプラットフォームで利用可能です。Linux環境で広く使用されています。

・Clang/LLVM
LLVMプロジェクトの一部であり、モジュラーで拡張性が高いコンパイラです。Mac OSやiOS開発でよく使用されます。

・MSVC (Microsoft Visual C++)
Windows環境での開発に特化したコンパイラで、Visual Studio IDEと密接に統合されています。
MSVCはWindows向けのデバッグツールが充実しています。
クロスプラットフォームの互換性が低い。Windows以外のプラットフォームでの使用は制限されます。

・Mingw-w64
MinGW（Minimalist GNU for Windows）の拡張版で、WindowsでGNUツールチェーンを使ってネイティブのWindowsアプリケーションを開発するためのものです。
GCCのWindows向けポートとして機能し、POSIX環境を必要としないWindowsアプリケーションの開発に適しています。

-------------------------------------

C++で、includeとusingは何が違いますか？
→C++におけるincludeとusingは、全く異なる目的で使用されるキーワードです。
#includeはプリプロセッサディレクティブであり、別のファイルの内容を現在のファイルに取り込むために使用されます。

usingディレクティブは、名前空間の内容を現在のスコープに取り込むために使用されます。これにより、特定の名前空間に属するすべての名前に対して、その名前空間の修飾子を付けずにアクセスできるようになります。

#includeは省略できないが、usingは省略することもできる、という認識は正しいですか？
→はい、その認識は正しいです。

C++の名前空間と、Javaのパッケージは同じ概念ですか？
→似た目的で使われるものの、完全に同じ概念ではありません。
Javaのパッケージはアクセス制御とディレクトリ構造と密接に結びついているのに対し、C++の名前空間はより柔軟で、主に名前の衝突を避けるために使用されます。

-------------------------------------

Makefileとは何ですか？
→UNIX系オペレーティングシステムで使用されるファイルの一種で、ソフトウェアのビルドプロセスを自動化するために使われます。
Makefileの主な機能は以下の通りです：
　自動化：複雑なビルドプロセスを自動化し、手動でのコンパイル手順を簡略化します。これにより、開発者はビルドプロセスを簡単に再現でき、一貫性のあるビルド結果が得られます。
　効率：Makefileはファイルの依存関係を管理し、変更されたファイルだけを再コンパイルすることでビルド時間を短縮します。これは、大規模なプロジェクトで特に重要です。
　カスタマイズ：開発者はMakefileを通じてビルドプロセスを細かく制御し、特定の環境や要件に合わせてカスタマイズできます。

Makefileは一般的に「Makefile」という名前で保存されることが多く、特定の拡張子を持たないのが一般的です。
この名前を使用すると、make コマンドを実行する際に特にファイル名を指定する必要がなく、自動的にこのファイルを探して利用します。
しかし、異なる設定や目的で複数のMakefileを用意したい場合は、ファイル名を変更して、make -f 指定したファイル名 の形で指定して実行することができます。

tasks.jsonは、ある意味でMakefileに似ていると言えますが、少し異なる目的と機能を持っています。
tasks.jsonはVSCodeの機能の一部であり、VSCode内で実行できるタスクを定義するファイルです。
これにより、コンパイル、テストの実行、リント処理など、さまざまな外部コマンドをVSCodeのワークフローに統合できます。

比較と対比
　目的の違い：Makefileは主にコンパイルとビルドプロセスの管理に特化しているのに対し、tasks.json はより広範なタスク（コードのビルド、テストの実行、スクリプトの起動など）をVS Code内で直接管理し実行するためのものです。
　環境の違い：Makefileは環境に依存せず、様々なシステムで使用できますが、tasks.json はVS Codeに固有の機能で、VS Codeがインストールされている環境でのみ使用可能です。
　カスタマイズ性：tasks.json はJSON形式で記述され、VS Codeの豊富な拡張機能と組み合わせることで高度なカスタマイズが可能です。一方、Makefileはシンプルなテキスト形式で、より技術的な知識が必要ですが、強力なビルド自動化を実現します。

結論として、tasks.json は Makefile に相当するというよりは、VS Code 環境内で多様なタスクを管理・実行するためのものと考えるべきでしょう。それぞれが異なるユースケースと環境に最適化されています。

-------------------------------------

c_cpp_properties.json
コードナビゲーションや自動補完の機能を有効にするためのファイル。
（これを設定しなくても、ビルドやデバッグは実行できる。）

-------------------------------------

launch.json
デバッグの設定

-------------------------------------

インクルードカードをつけなかった結果、多重インクルードが走りました。この場合エラーになりますか？
→多重インクルードが引き起こす問題
重複定義: クラスや関数、変数などが複数回定義されると、リンカエラー（特に「重複定義」のエラー）につながる可能性があります。
コンパイル時間の増加: 同じヘッダファイルが何度もコンパイルされるため、ビルドプロセスが遅くなります。

インクルードガードまたはプラグマ・ワンスがない: リンカーエラーやその他のコンパイルエラーが発生する可能性があります。

-------------------------------------

a.cppがa.hppをインクルードしている。
a.hppは、
#include <iostream>
using namespace std;
と書いている。

この時、a.cppで改めて
#include <iostream>
using namespace std;
と書く必要はない。

-------------------------------------

・ポインタについて
int *b; →宣言されるのはbという変数であり、*bという変数ではない。*は宣言子である。
*には2つの意味がある。
変数宣言の中で使うと宣言子であり、代入文の中で使うと、間接参照演算子である。
*b = 3;

なお、int *bb = 1;というのは、実行時に以下のエラーになる。
invalid conversion from 'int' to 'int*' [-fpermissive]

・変数に&演算子をつけると、その変数のアドレスが取得できる。
　このアドレスのことを、その変数へのポインタと呼ぶ。
・ポインタに*演算子をつけると、そのポインタの指している先のものを指すようになる。
hoge_pがhogeを指しているなら、*hoge_pは、hogeと同じものを表す。


-------------------------------------

データ型のサイズは決まっていない。実行環境によって異なる。
一般的には、CPUとコンパイラが同じであれば違いがあることは少ないが、常に同じであるとは言えない。
例えば、同じCPUでgccという同じコンパイラを使っても、WindowsとLinuxではlongのサイズが異なる。

